# N Things I Wish I Knew About Programming Before I Started Programming

### 1. Style Matters
The minute that you can write code is the second you should be worried about style.

In Kindergarten, you learned how to write letters. Did you just scribble out anything that looked vaguely like letters? No. You were given a workbook and you traced letters to match what they should look like because there are standards to what they should look like.

Similarly, by adhering to a disciplined style, your code will be easier to read. When you encounter a problem, your consistent style will make it more obvious when something is amiss. Even more importantly, if you ever need help and have to show your code to someone else, make it as easy as possible for them to help you. Looking at other people's code is hard enough. Looking at other people's poorly styled code is frustrating and makes it harder to help you.

### 2. Talk It Out
Verbalizing your problems can reveal your errors.

Sometimes I feel that I think in a language that only I can understand. When I get stuck I feel like I'm cornered and don't know where to turn. Since I do my best coding alone at home, I can't easily ask for help. I have found one of the best remedies was to merely speak my thinking process aloud to myself. The conversion from my unique mental language to spoken English, and then translating it back to my mental language after reconsuming the logic has often made me realize that logic was nonsense.

A similar phenomenon is called [Rubber Duck Debugging](http://pressupinc.com/blog/2014/06/psychology-underlying-power-rubber-duck-debugging/). Imagine that you're explaining your code to a completely ignorant rubber duck. You will be forced to slow down your thinking and explain it in a way that takes no knowledge for granted, revealing a mistake you might quickly gloss over. This also applies to teaching others in order to reinforce your own knowledge. By slowing down and explaining every single step you have to think about the problems in ways that you don't otherwise think of when using your own mental processes.

### 3. Comment As You Go
When you write a non-trivial piece of code, take a second to write a small sentence about what it does.

This ties into tip number 2. If you build something that requires more than a glance to the average coder, leave a comment. Have the reader read a plain English description of your logic rather than forcing them to trace the steps. If you ask someone for help on some of your code, they are going to be more lost than you. Leaving comments is like leaving the next person breadcrumbs to navigate through your forest of code.

Sometimes, you're going to be the next person that has to look at your code. Do you want to look at your own undocumented code to figure out what the heck you were thinking 7 months ago? Why would you do that to yourself? Do yourself a favor. [Leave a note.](http://media1.mic.com/site/article-items/2739/1_gif.gif) It's like leaving a present for your future self. Future-You will be happy you did.

### 4. Computer Science is Essentially Applied Mathematics
Strictly speaking you won't use much advanced math when programming, yet having an advanced math background allows you to be a better thinker when you face a problem.

Intricate logic, algorithms, and recursions are at the root of every program which require very abstract thinking. Having a strong foundation in math stretches your mental capacity beyond what you can visualize and keeps you disciplined in your methods. Conceptualizing the ideas of limits, the puzzle solving of integration, and the testing of infinite series all prepared my mind for highly abstract programming.

I would go so far as to say that those that are poor in math are the poorest programmers. If you are self-admittedly poor at math, then you should remedy that or reconsider your path.

### 5. Work Top-Down (Think First, Code Later)
"Bad programmers worry about the code. Good programmers worry about data structures and their relationships." -Linus Torvalds

Design your algorithms first at the highest level, i.e. explain in English each step on your path to the answer. Then, translate your English into more mathematical, logical operations via flow charts. Then finally, you can translate your logic into code.

Coding should be the last thing you ever do with your program. If you can envision your data structures and work flow in your head and on paper, then creating the code will be the easiest part. 

### 6. Programming Takes Time; Start Early
When you first face a problem, your vision is limited to the surface. There are problems beneath the surface that you cannot even imagine until you actually get your hands on it. Affording yourself downtime allows you to digest unexpected problems.

The importance of starting early cannot be overstated. On the path to the solution you may find that your first draft algorithm is returning bad results, or you don't actually know how to use some feature, or you find an edge case you have no idea how to handle. I guarantee that you will always hit a bump in the road in development and it will derail your projected finishing time. If you decided to make your program 2 days before it's due, then your back is completely against the wall. If you started working on it 2 weeks before the due date then, you have many days to step back from the project and ponder on the strange occurrence.

When you step back from the project, a funny thing happens. By freeing your mind of burden for a while, you can come back to the project with clearer eyes, and from a new perspective. You can come back to see that you were actually calling methods on a NULL node (instead of the node that points to a NULL node) which caused you six plus hours of seg faults and headaches (true story). Sometimes it doesn't even take that long have a flash of brilliance. I cannot recall how many algorithms I've solved in that strange hinterland between wake and sleep.

### 7. Revision Is A Gift From You To Yourself
##### Michael's Conjecture: Any human at time T is more intelligent than he or she was at time T-n, where n is a length of time greater than zero.
##### Proof(?): Assume towards contradiction that a human at time T is less intelligent then he or she was at time T-n. Therefore, the human is discarding knowledge, or the mind's intellectual capacity is shrinking, or that there is an upper bound on a person's intelligence. Therefore, one becomes more dim over time. This assumption contradicts the idea that knowledge and experience can be collected over time and thereby cause ones mental capacities to expand by virtue of what has been learned. Because the assumption leads to contradiction, we must conclude that the original proposition is true. QED(?)

In conjunction with number 6, if you allow yourself excess time to ponder your project, then you will have time to revise. By my conjecture, the person who revises your work (i.e. you) will be smarter than the person who wrote it (i.e. you). You will be able to look over your work with keener senses than they were at the time of construction.


### 8 through N To be continued...
